# Redis

## 简介

Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。

Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。

除此之外，Redis 还支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制等等。

## Redis线程模型

Redis 单线程模型是指 `接收客户端请求 -> 解析请求 -> 进行数据读写 -> 发送给客户端` 这一个过程是是由一个线程「主线程」完成的. 这就是Redis是单线程的原因.

但是Redis程序并不是单线程, 是会启动后台进程「BIO」的.

1. 在Redis 2.6版本, Redis会启动两个后台线程, 用来关闭文件和AOF刷盘
2. 在Redis 4.0版本以后, 新增了一个后台线程,用来异步释放Redis内存,也就是lazyfree线程.

### 后台线程工作机制

简单来说, 后台线程和主线程就是**生产者-消费者模型**

![work](http://picbed.fjhdream.cn/202312121549034.png)

关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：

- BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；
- BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，
- BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；

### 单线程工作方式

![work](http://picbed.fjhdream.cn/202312121549045.png)

Redis 初始化的时候，会做下面这几件事情：

1. 首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket
2. 然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；
3. 然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。

初始化完后，主线程就进入到一个事件循环函数，主要会做以下事情：

1. 首先，先调用**处理发送队列函数**，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。
2. 接着，调用 epoll_wait 函数等待事件的到来：
    - 如果是**连接事件**到来，则会调用**连接事件处理函数**，该函数会做这些事情：调用 accpet 获取已连接的 socket -> 调用 epoll_ctl 将已连接的 socket 加入到 epoll -> 注册「读事件」处理函数；
    - 如果是**读事件**到来，则会调用**读事件处理函数**，该函数会做这些事情：调用 read 获取客户端发送的数据 -> 解析命令 -> 处理命令 -> 将客户端对象添加到发送队列 -> 将执行结果写到发送缓存区等待发送；
    - 如果是**写事件**到来，则会调用**写事件处理函数**，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。

## 持久化

Redis的读写都是在内存中, 所以Redis才性能如此快, 那么当Redis重启后, 又是怎么能保证内存中的数据不丢失呢? 这就依赖于Redis中的持久化机制.

目前Redis的持久化方式有三种:

1. AOF日志模式: 每执行一个命令, 就将此命令记录到日志文件中.
2. RDB快照: 将某一时刻内存的数据, 二进制数据保存到磁盘中.
3. 混合持久化: AOF和RDB混合使用

### AOF策略

目前AOF有三种写回策略:

1. Always: 每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；
2. Everysec: 每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；
3. No: 意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。

#### AOF重写机制

随着命令操作越来越多, AOF的日志文件也会越来越大. 如果redis此时重启, 重新加载这些命令, 那么也会耗费非常多的时间. Reids是如何减缓减轻这种情况的产生的呢?

Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。

Redis 的重写机制是由后台**子进程** `bgrewriteaof` 来执行, 这样有两个好处.

1. 重写过程中, 不会阻塞主进程处理请求
2. 使用子进程, 会有主进程的内存副本, 当发生读写时依赖**写时复制**保证数据安全, 也不用加锁保证性能.

在重写 AOF 期间，主进程和子进程数据不一致, 这时候Redis又该怎么处理呢? 当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」

也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:

- 执行客户端发来的命令
- 将执行后的写命令追加到 「AOF 缓冲区」
- 将执行后的写命令追加到 「AOF 重写缓冲区

当子进程完成 AOF 重写工作后,会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作:

- 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；
- 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。
信号函数执行完后，主进程就可以继续像往常一样处理命令了。
